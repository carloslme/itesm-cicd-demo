name: CD Pipeline

on:
  push:
    branches: [ main ]
    paths: [ 'docker-compose.yml', 'src/**' ]
  workflow_dispatch:
    inputs:
      model_version:
        description: 'Model version (v1 or v2)'
        required: true
        default: 'v2'
        type: choice
        options: ['v1', 'v2']

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Get model version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          MODEL_VERSION="${{ github.event.inputs.model_version }}"
          echo "Using manual input: $MODEL_VERSION"
        else
          MODEL_VERSION=$(grep -E "MODEL_VERSION.*:-.*" docker-compose.yml | sed -n 's/.*MODEL_VERSION.*:-\([^}]*\).*/\1/p' | tr -d ' ')
          echo "Extracted from docker-compose.yml: $MODEL_VERSION"
        fi
        
        if [ "$MODEL_VERSION" != "v1" ] && [ "$MODEL_VERSION" != "v2" ]; then
          echo "Error: Invalid model version '$MODEL_VERSION'. Must be 'v1' or 'v2'"
          exit 1
        fi
        
        echo "model_version=$MODEL_VERSION" >> $GITHUB_OUTPUT
        echo "Selected model version: $MODEL_VERSION"
    
    - name: Check existing EC2 instance
      id: ec2-check
      run: |
        if [ -f "ec2-instance-info.txt" ]; then
          INSTANCE_ID=$(grep "Instance ID:" ec2-instance-info.txt | cut -d' ' -f3 2>/dev/null || echo "")
          if [ ! -z "$INSTANCE_ID" ]; then
            STATUS=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "not-found")
            echo "instance_status=$STATUS" >> $GITHUB_OUTPUT
            echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
            echo "Found existing instance: $INSTANCE_ID (status: $STATUS)"
          else
            echo "instance_status=not-found" >> $GITHUB_OUTPUT
          fi
        else
          echo "instance_status=not-found" >> $GITHUB_OUTPUT
          echo "No existing instance info found"
        fi
    
    - name: Get latest Amazon Linux AMI
      id: ami
      run: |
        # Get the latest Amazon Linux 2023 AMI ID for current region
        AMI_ID=$(aws ec2 describe-images \
          --owners amazon \
          --filters "Name=name,Values=al2023-ami-*-x86_64" \
                   "Name=state,Values=available" \
          --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
          --output text)
        
        if [ "$AMI_ID" = "None" ] || [ -z "$AMI_ID" ]; then
          # Fallback to Amazon Linux 2
          echo "‚ö†Ô∏è AL2023 not found, trying Amazon Linux 2..."
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=amzn2-ami-hvm-*-x86_64-gp2" \
                     "Name=state,Values=available" \
            --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
            --output text)
        fi
        
        if [ "$AMI_ID" = "None" ] || [ -z "$AMI_ID" ]; then
          echo "‚ùå Could not find suitable AMI"
          exit 1
        fi
        
        echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
        echo "‚úÖ Using AMI: $AMI_ID"
    
    - name: Create EC2 instance if needed
      if: steps.ec2-check.outputs.instance_status != 'running'
      run: |
        echo "üöÄ Creating new EC2 instance..."
        AMI_ID="${{ steps.ami.outputs.ami_id }}"
        
        # Create unique names with timestamp
        TIMESTAMP=$(date +%s)
        KEY_NAME="ml-demo-key-$TIMESTAMP"
        SG_NAME="ml-demo-sg-$TIMESTAMP"
        
        # Create key pair
        echo "Creating key pair: $KEY_NAME"
        aws ec2 create-key-pair --key-name $KEY_NAME \
          --query 'KeyMaterial' --output text > $KEY_NAME.pem
        chmod 400 $KEY_NAME.pem
        
        # Create security group
        echo "Creating security group: $SG_NAME"
        SG_ID=$(aws ec2 create-security-group \
          --group-name $SG_NAME \
          --description "ML Demo Security Group - $TIMESTAMP" \
          --query 'GroupId' --output text)
        
        echo "Security group created: $SG_ID"
        
        # Allow SSH (port 22)
        echo "Adding SSH rule..."
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID --protocol tcp --port 22 --cidr 0.0.0.0/0
        
        # Allow HTTP on port 8000
        echo "Adding HTTP rule for port 8000..."
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID --protocol tcp --port 8000 --cidr 0.0.0.0/0
        
        # Create user data script
        cat > user-data.sh << 'EOF'
        #!/bin/bash
        yum update -y
        yum install -y python3 python3-pip git docker
        systemctl start docker
        systemctl enable docker
        usermod -a -G docker ec2-user
        
        # Install Docker Compose
        curl -L "https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        chmod +x /usr/local/bin/docker-compose
        ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
        EOF
        
        # Launch instance
        echo "Launching EC2 instance with AMI: $AMI_ID"
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id $AMI_ID \
          --count 1 \
          --instance-type t3.micro \
          --key-name $KEY_NAME \
          --security-group-ids $SG_ID \
          --user-data file://user-data.sh \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=ML-Demo-Instance},{Key=Project,Value=ITESM-CICD-Demo}]' \
          --query 'Instances[0].InstanceId' \
          --output text)
        
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
          echo "‚ùå Failed to create instance"
          exit 1
        fi
        
        echo "‚úÖ Instance created: $INSTANCE_ID"
        
        # Wait for instance to be running
        echo "‚è≥ Waiting for instance to be running..."
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID
        
        # Get public IP
        PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        
        if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "None" ]; then
          echo "‚ùå Could not get public IP"
          exit 1
        fi
        
        # Save instance info
        cat > ec2-instance-info.txt << EOF
        Instance ID: $INSTANCE_ID
        Public IP: $PUBLIC_IP
        Key Name: $KEY_NAME
        Security Group: $SG_ID
        AMI ID: $AMI_ID
        Created: $(date)
        EOF
        
        echo "‚úÖ EC2 instance created successfully!"
        echo "Instance ID: $INSTANCE_ID"
        echo "Public IP: $PUBLIC_IP"
        echo "AMI ID: $AMI_ID"
        
        # Wait for instance to be fully ready
        echo "‚è≥ Waiting for instance initialization (2 minutes)..."
        sleep 120
    
    - name: Deploy application to EC2
      run: |
        MODEL_VERSION="${{ steps.version.outputs.model_version }}"
        GITHUB_REPO="${{ github.repository }}"
        
        # Get instance details
        PUBLIC_IP=$(grep "Public IP:" ec2-instance-info.txt | cut -d' ' -f3)
        KEY_NAME=$(grep "Key Name:" ec2-instance-info.txt | cut -d' ' -f3)
        
        echo "üöÄ Deploying $MODEL_VERSION to $PUBLIC_IP"
        echo "üì¶ Repository: $GITHUB_REPO"
        
        # Wait for SSH to be available
        echo "‚è≥ Waiting for SSH to be available..."
        for i in {1..30}; do
          if ssh -i $KEY_NAME.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
             ec2-user@$PUBLIC_IP "echo 'SSH Ready'" 2>/dev/null; then
            echo "‚úÖ SSH connection established!"
            break
          fi
          echo "Waiting for SSH... ($i/30)"
          sleep 10
        done
        
        # Create deployment script with variables already substituted
        cat > deploy-app.sh << EOF
        #!/bin/bash
        set -e
        
        echo "üîß Setting up application..."
        
        # Clone repository
        if [ -d "itesm-cicd-demo" ]; then
            echo "Updating existing repository..."
            cd itesm-cicd-demo
            git pull origin main
        else
            echo "Cloning repository..."
            git clone https://github.com/${GITHUB_REPO}.git itesm-cicd-demo
            cd itesm-cicd-demo
        fi
        
        # Install Python dependencies
        echo "Installing Python dependencies..."
        pip3 install --user -r requirements.txt
        
        # Create models directory
        mkdir -p src/api/models
        
        # Train the model
        echo "Training ${MODEL_VERSION} model..."
        export PYTHONPATH=/home/ec2-user/itesm-cicd-demo
        if [ "${MODEL_VERSION}" = "v1" ]; then
            python3 src/training/train.py 1
        else
            python3 src/training/train.py 2
        fi
        
        # Kill any existing API process
        pkill -f "uvicorn src.api.main:app" || true
        sleep 5
        
        # Start the API
        echo "Starting API server..."
        export MODEL_VERSION=${MODEL_VERSION}
        export PYTHONPATH=/home/ec2-user/itesm-cicd-demo
        nohup python3 -m uvicorn src.api.main:app --host 0.0.0.0 --port 8000 > /home/ec2-user/api.log 2>&1 &
        
        echo "‚úÖ Deployment completed!"
        echo "API log location: /home/ec2-user/api.log"
        EOF
        
        # Copy and execute deployment script
        echo "üì§ Copying deployment script..."
        scp -i $KEY_NAME.pem -o StrictHostKeyChecking=no \
          deploy-app.sh ec2-user@$PUBLIC_IP:/tmp/
        
        echo "üöÄ Executing deployment..."
        ssh -i $KEY_NAME.pem -o StrictHostKeyChecking=no \
          ec2-user@$PUBLIC_IP \
          "chmod +x /tmp/deploy-app.sh && /tmp/deploy-app.sh"
    
    - name: Test deployment
      run: |
        PUBLIC_IP=$(grep "Public IP:" ec2-instance-info.txt | cut -d' ' -f3)
        MODEL_VERSION="${{ steps.version.outputs.model_version }}"
        
        echo "üß™ Testing deployment at $PUBLIC_IP:8000"
        
        # Wait for API to be ready
        echo "‚è≥ Waiting for API to be ready..."
        for i in {1..60}; do
          if curl -f -s "http://$PUBLIC_IP:8000/health" > /dev/null; then
            echo "‚úÖ API is ready!"
            break
          fi
          echo "Waiting for API... ($i/60)"
          sleep 5
        done
        
        # Test endpoints
        echo "üîç Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -f "http://$PUBLIC_IP:8000/health")
        echo "Health response: $HEALTH_RESPONSE"
        
        echo "üîç Testing model-info endpoint..."
        MODEL_INFO=$(curl -f "http://$PUBLIC_IP:8000/model-info")
        echo "Model info: $MODEL_INFO"
        
        # Verify model version
        DEPLOYED_VERSION=$(echo "$MODEL_INFO" | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
        if [ "$DEPLOYED_VERSION" = "$MODEL_VERSION" ]; then
          echo "‚úÖ Model version verified: $DEPLOYED_VERSION"
        else
          echo "‚ö†Ô∏è Model version mismatch: expected $MODEL_VERSION, got $DEPLOYED_VERSION"
        fi
        
        echo "üîç Testing prediction endpoint..."
        PREDICTION=$(curl -f "http://$PUBLIC_IP:8000/predict?sepal_length=5.1&sepal_width=3.5&petal_length=1.4&petal_width=0.2")
        echo "Prediction response: $PREDICTION"
        
        echo "‚úÖ All deployment tests passed!"
    